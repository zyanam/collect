1. #### 自增变量，写出程序运行结果。

   1. ```java
          /**
           * 自增变量
           *
           * @param args
           */
          public static void main(String[] args) {
              int i = 1;
              i = i++;
              int j = i++;
              int k = i + ++i * i++;
              
              System.out.println("i=" + i);
              System.out.println("j=" + j);
              System.out.println("k=" + k);
          }
      ```

   2. 运行结果

      - i=4,j=2,k=11

   

   

2. #### 写一个单例模式。要求：

   1. 线程安全

   2. 延迟加载

   3. ```java
   public class Singleton2 {
      
          private Singleton2() {
          }
      
          private static class Inner {
              private static final Singleton2 INSTANCE = new Singleton2();
          }
      
          public static Singleton2 getInstance() {
              return Inner.INSTANCE;
          }
      }
      ```

   4. ```java
   public class Singleton3 {
          private Singleton3() {
          }
      
          private static Singleton3 instance;
      
          public static Singleton3 getInstance() {
              if (instance == null) {
                  synchronized (Singleton3.class) {
                      if (instance == null) {
                          instance = new Singleton3();
                      }
                  }
              }
              return instance;
          }
      }
      ```

3. #### 类初始化和对象实例化，写出打印顺序

   1. ```java
      public class Father {
          private int i = test();
          private static int j = method();
      
          static {
              System.out.println("(1)");
          }
      
          Father() {
              System.out.println("(2)");
          }
      
          {
              System.out.println("(3)");
          }
      
          public int test() {
              System.out.println("(4)");
              return 1;
          }
      
          public static int method() {
              System.out.println("(5)");
              return 1;
          }
      }
      ```

   2. ```java
      public class Son extends Father {
          private int i = test();
          private static int j = method();
      
          static {
              System.out.println("(6)");
          }
      
          Son() {
              System.out.println("(7)");
          }
      
          {
              System.out.println("(8)");
          }
      
          public int test() {
              System.out.println("(9)");
              return 1;
          }
      
          public static int method() {
              System.out.println("(10)");
              return 1;
          }
      
          public static void main(String[] args) {
              Son s1 = new Son();
              System.out.println();
              Son s2 = new Son();
          }
      }
      ```

   3. 步骤

      1. 类初始化：
         1. 先初始化main方法所在的类。
         2. 如果有父类，先初始化父类。
         3. 静态变量赋值和静态代码块，从上到下按顺序执行。
      2. 对象实例化：
         1. super();
         2. 非静态变量赋值
         3. 非静态代码块
         4. 构造函数
      3. 重写方法调用
         1. 初始化父类时，如果调用的方法被子类重载，则调用的是子类的方法。

4. #### 方法的参数传递机制

   1. ```java
      public class Exam4 {
          public static void main(String[] args) {
              int i = 1;
              String str = "hello";
              Integer num = 2;
              int[] arr = {1, 2, 3, 4, 5};
              MyData my = new MyData();
      
              change(i, str, num, arr, my);
      
              System.out.println("i = " + i);
              System.out.println("str = " + str);
              System.out.println("num = " + num);
              System.out.println("arr = " + Arrays.toString(arr));
              System.out.println("my.a = " + my.a);
          }
      
          public static void change(int j, String s, Integer n, int[] a, MyData m) {
              j += 1;
              s += "world";
              n += 1;
              a[0] += 1;
              m.a += 1;
          }
      
      }
      
      class MyData {
          int a = 10;
      }
      ```

   2. 结果

      1. ```java
      i = 1
         str = hello
         num = 200
         arr = [2, 2, 3, 4, 5]
         my.a = 11
         ```

      2. String类型和包装类不可变

5. #### （*）有n个台阶，一次只能上1个台阶或2两个台阶，共有多少种走法？

   1. 斐波那契数列，从第3个数开始，每个数都等于前两个数之和。

   2. 递归

      1. ```java
             private int recursion(int n) {
                 if (n > 0 && n <= 2) {
                     return n;
                 }
         
                 return recursion(n - 2) + recursion(n - 1);
          }
         ```

   3. 循环

      1. ```java
             private int loop(int n) {
              if (n > 0 && n <= 2) {
                     return n;
              }
         
                 int r1 = 1;
                 int r2 = 2;
                 int r3 = 0;
                 for (int i = 3; i <= n; i++) {
                     r3 = r2 + r1;
                     r1 = r2;
                     r2 = r3;
                 }
                 return r3;
             }
         ```

6. #### 成员变量与局部变量

   1. 给出运行结果

   2. ```java
      public class Scope {
          static int s;
          int i;
          int j;
          {
              int i = 1;
              i++;
              j++;
              s++;
          }
          public void test(int j){
              i++;
              j++;
              s++;
          }
      
          public static void main(String[] args) {
              Scope s1 = new Scope();
              Scope s2 = new Scope();
              s1.test(10);
              s1.test(20);
              s2.test(30);
              System.out.println(s1.i + "," + s1.j + "," + Scope.s);
              System.out.println(s2.i + "," + s2.j + "," + Scope.s);
          }
      }
      ```

   3. 结果

      - 2,1,5
      - 1,1,5

7. #### Spring Bean 的作用域的区别
   
| 使用@Scope注解 |                                                              |
| -------------- | ------------------------------------------------------------ |
| 注解值         | 说明                                                         |
| singleton      | 默认作用域，程序启动时自动创建，单例模式。                   |
| prototype      | 程序启动不创建，每次从容器种获取再创建，获取一次创建一次。   |
| request        | 每次HTTP请求都会创建一个新的Bean,只在WebApplicationContext有效。 |
| session        | 同一个HTTP Session 共享一个Bean,不同的 HTTP Session 使用不同的Bean,只在WebApplicationContext有效。 |

8. Spring 支持的常用数据库事务的传播属性和隔离级别

   1. 事务的传播属性，@Transactional(propagation=Propagation.REQUIRED)

      1. | 传播属性     | 描述                                                         |
         | ------------ | ------------------------------------------------------------ |
         | REQUIRED     | 如果有事务在运行，当前的方法就在这个事务内运行，否则就启动一个新事务。 |
         | REQUIRED_NEW | 当前的方法必须启动新事务，并在自己的事务内运行，如果有事务正在运行，则将其挂起 |
         | SUPPORT      | 如果有事务在运行，当前的方法就在这个事务内运行。否则此方法可以不运行在事务中。 |
         | NOT_SUPPORT  | 当前方法不应该运行在事务中，如果有运行的事务，将其挂起。     |
         | MANDATORY    | 当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常。 |
         | NEVER        | 当前的方法不应该运行在事务中，如果有运行的事务就抛出异常。   |
         | NESTED       | 如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行。 |

      

   2. 两个事务同时工作可能出现的异常情况

      1. 脏读：读取了未提交的值。第一个事务修改了值，还未提交，第二个事务读取了值，第一个事务出现异常，回滚，恢复了原来的值，第二个事务拿到了一个无效的值。
      2. 不可重复读：读取和再次读取的值不一致。第一个事务读取了值后，第二个事务修改了值，第一个事务再次读取的值和上一次读取的值不一致。
      3. 幻读：第一个事务查询数据库表中user_name是否重复，返回false，第二个事务插入了同样user_name的一行数据，第一个事务再提交的时候会报主键重复异常。

   3. 隔离级别,级别越高一致性越好，但是并发性越差。

      1. 读未提交:

   

   

   